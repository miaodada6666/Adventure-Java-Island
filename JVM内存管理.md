# JVM内存管理
与其他高级语言（例如C和C++）不同,在Java中我们基本上不会显示地调用分配内存的函数，我们甚至都不用关心哪些程序指令需要分配内存，需要分配多少的内存。因为在JVM当中，内存的分配和回收都已经由JVM自动完成了，很少会遇到C++程序中OutOfMemoryError这样的内存泄露问题。  
虽然Java语言的这些特点在很大程度上减少了开发人员的麻烦，但是我们最好还是了解一下Java是如何管理内存的，当我们真正遇到内存泄漏问题时，能够根据报错信息迅速找到内存泄漏的代码并成功dubug！  
本章将会从以下几个方面介绍JVM的内存管理机制。  
- 从操作系统层面介绍物理内存的分配和Java运行的内存分配之间的关系。
- Java如何使用从物理内存申请下来的内存，以及如何来划分他们。
- 如何分配和回收内存
- 通过一些例子介绍如何解决OutOfMemoryError，并提供一些处理这类问题常用的手段。
## 物理内存和虚拟内存
所谓物理内存就是我们通常所说的RAM（随机存储器）。在计算机中，还有一个存储单元叫寄存器（在CPU中），它用于存储计算单元执行指令的中间结果。寄存器的大小决定了一次计算可使用的最大数值。通常操作系统管理内存的申请空间是按照进程来管理的，即每个进程拥有一段独立的物理空间地址，每个进程之间不会相互重合，操作系统也会保证每个进程只能访问自己的内存空间。  
其实上面所说的进程的内存空间的独立主要是指逻辑上独立，这个独立是由操作系统来保证的。但是真正的物理空间是不是只能由一个进程来使用就不一定了。因为随着程序越来越大，物理内存无法满足程序的需求，在这种情况下就有了虚拟内存的出现。  
虚拟内存的出现使得多个进程在同时运行时可以共享物理内存，这里的共享只是空间上的共享，在逻辑上他们仍是不能相互访问的。虚拟地址不但可以让进程共享物理内存，提高内存的利用率，同时还能够扩展内存的地址空间。如一段虚拟地址可能被映射到一段物理内存、文件或者其他可以寻址的存储上。一个进程在不活动的情况下，操作系统将这个线程的数据从物理内存移到磁盘文件中，而真正高效的物理内存留给正在活动的程序使用。当唤醒了一个很长时间没有使用到的程序时，操作系统又会把磁盘上的数据重新交互到物理内存中，但是我们要避免这种情况经常出现，因为数据的频繁交互会影响计算机的性能。
## 用户空间和内核空间
 一个计算机通常具有一定大小的内存空间（平常所说的内存条），比如4GB，8GB，16GB等，但是程序并不能完全使用这些地址空间。因为这些地址空间被分为用户空间和内核空间，程序只能使用用户空间。  
 内核空间是指操作系统运行时所使用的用于程序调度，虚拟内存的使用和连接硬件资源的内存空间。为何需要划分内核空间和用户空间呢？也是出于安全的考虑，类似于上文所说的每个线程都独立使用属于自己的内存，互不干扰一样，用户程序也不能访问操作系统本身所使用的内存空间。  
 但如果用户程序也有访问硬件资源的需求时怎么办呢（例如网络连接）？可以通过调用操作系统所提供的接口来实现，这个调用操作系统接口的过程也就是系统调用。每一次系统调用都会存在两个内存空间的切换，例如网络连接就是一次系统调用，通过网络传输的数据先是从内核空间接收到远程主机的数据，然后再从内核空间复制到用户空间，供用户程序使用。然而，这种数据在内核空间和用户空间之间的转化很费时，虽然保证了程序运行的安全性和稳定性，但是也牺牲了一部分效率。现在已经出现了很多其他技术能够减少这种从内核空间到用户空间的数据复制的方式，如Linux系统提供的sendfile文件传输方式。  
 内核空间和用户空间大小如何分配也是一个问题，要根据计算机的工作重心分配不同大小的内核空间和用户空间。
 ## JVM内存结构
 JVM是按照运行时数据的存储结构来划分内存结构的，JVM在运行Java程序时，将他们划分成几种不同格式的数据，分别存储在不同的区域，这些数据统一称为运行时数据（Runtime Data）。在JVM中，将Java运行时数据划分为以下六种：  
 - PC寄存器数据
 - Java栈
 - 堆
 - 方法区
 - 本地方法区
 - 运行时常量池
 ### PC寄存器
 PC寄存器严格来说是一种数据结构，（PC寄存器在CPU当中，线程是CPU分配的基本单位，每个线程都拥有自己的PC寄存器）它用于保存当前正在执行的程序的内存地址。由于Java程序是支持多线程执行的，所以不可能保证每个线程都按照线性执行下去，可能线程1执行到一半cpu资源被线程2夺去，线程1发生中断。被中断的线程当前执行到哪条内存地址必然要保存下来，以便它被恢复执行时可以从中断处继续执行，这个用于保存线程当前正在执行的内存地址的数据结构就是PC寄存器，它就像一个记录员一样记录下哪个线程执行到哪条指令了。  
 ### Java栈
 Java栈总是与Java线程关联在一起，每创建了一个线程时，JVM就会为这个线程创建一个对应的Java栈。这个Java栈中又会含有多个栈帧（Frames），每个栈帧都会对应一个方法，每个栈帧会含有一些内部变量（方法内部定义的变量）、操作栈和方法返回值等信息  
 每当一个方法执行完成时，这个栈帧就会弹出栈帧的元素作为这个方法的返回值，并清除这个栈帧，Java栈的栈顶的栈帧就是这个当前正在执行的活动栈，也就是当前正在执行的方法，PC寄存器也会指向这个栈帧的内存地址。只有这个活动的栈帧的本地变量可以被操作栈使用，当在这个栈帧中调用另外一个方法时，与之对应的一个新的栈帧又被创建，这个新创建的栈帧又被放在Java栈的顶部，变为当前的活动栈帧。同样现在只有这个栈帧的本地变量能够被操作栈使用，当这个栈帧中所有的指令执行完时这个栈帧移出Java栈，刚才的那个栈帧又变为活动栈帧，前面的栈帧的返回值又变为这个栈帧的操作栈中的一个操作数。如果前面的栈帧没有返回值，那么当前的栈帧的操作栈的操作数没有变化。  
 ### 堆
 堆是存储Java对象的地方，它是JVM管理Java对象的核心区域，所有new出来的对象都存储在这里。堆也是我们的应用程序与内存关系最密切的存储区域。   
 每一个存储在堆中的Java对象都会是这个对象的类的一个副本，它会复制包括继承自它父类的所有静态属性。由于堆是被所有Java线程所共享的，所以对它的访问要注意同步问题。方法和对应的属性都要保持一致性。
 ### 方法区
 JVM方法区是用来存储类结构信息的地方。当通过类加载器将一个class文件解析成JVM能识别的几个部分时，这些不同的部分会被存储在不同的数据结构当中，其中的常量池、域、方法数据、方法体、构造函数，包括类中的专有方法、接口初始化等都存储在这个区域。  
 方法区也属于堆的一部分，也就是我们通常说的Java堆中的永久区，这个区域可以被所有的线程共享，并且它的大小可以通过参数来设置。  
 对于方法区来说，它所存储区域的大小一般在程序启动后的一段时间就是固定的了，JVM云顶一段时间后，需要加载的类通常都已经加载到JVM当中了。但是有一种情况需要注意，那就是项目中存在动态编译的情况（Java语言是编译完再统一执行的，那么如果一个java程序在执行时调用了另外一个程序或者class文件，那么就要在执行的过程中编译这个新的被调用的文件，这就叫做动态编译），那么此时需要观察方法区的大小能否满足类存储。
 ### 本地方法栈
 本地方法栈